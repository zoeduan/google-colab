<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">CODEBPE: INVESTIGATING SUBTOKENIZATION OPTIONS FOR LARGE LANGUAGE MODEL PRETRAINING ON SOURCE CODE</title>
				<funder ref="#_JKE6qxR">
					<orgName type="full">Russian Science Foundation</orgName>
				</funder>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability  status="unknown">
					<licence/>
				</availability>
				<date type="published" when="2023-08-01">1 Aug 2023</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Nadezhda</forename><surname>Chirkova</surname></persName>
							<email>nadia.chirkova@naverlabs.com</email>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">University of Amsterdam</orgName>
								<orgName type="institution" key="instit2">HSE University</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Naver</forename><surname>Labs Europe</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">University of Amsterdam</orgName>
								<orgName type="institution" key="instit2">HSE University</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Sergey</forename><surname>Troshin</surname></persName>
							<email>s.troshin@uva.nl</email>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">University of Amsterdam</orgName>
								<orgName type="institution" key="instit2">HSE University</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">CODEBPE: INVESTIGATING SUBTOKENIZATION OPTIONS FOR LARGE LANGUAGE MODEL PRETRAINING ON SOURCE CODE</title>
					</analytic>
					<monogr>
						<imprint>
							<date type="published" when="2023-08-01">1 Aug 2023</date>
						</imprint>
					</monogr>
					<idno type="MD5">0683125A04026DDBE65D17FCABFD6C22</idno>
					<idno type="arXiv">arXiv:2308.00683v1[cs.LG]</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.8.2-SNAPSHOT" ident="GROBID" when="2025-04-29T15:55+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<label type="revision">92ea31e</label>
					<label type="parameters">startPage=-1, endPage=-1, consolidateCitations=1, consolidateHeader=1, consolidateFunders=0, includeRawAffiliations=false, includeRawCitations=false, includeRawCopyrights=false, generateTeiIds=false, generateTeiCoordinates=[], flavor=null</label>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>&apos;i&apos;</term>
					<term>&apos;in&apos;</term>
					<term>&apos;range&apos;</term>
					<term>&apos;(&apos;</term>
					<term>&apos;df&apos;</term>
					<term>&apos;.&apos;</term>
					<term>&apos;shape&apos;</term>
					<term>&apos;[&apos;</term>
					<term>&apos;1&apos;</term>
					<term>&apos;] ) :&apos;</term>
					<term>&apos;NEW˙LINE INDENT&apos;</term>
					<term>&apos;print&apos;</term>
					<term>&apos;(&apos;</term>
					<term>&apos;i&apos;</term>
					<term>&apos;) NEW˙LINE&apos;</term>
					<term>&apos;print&apos;</term>
					<term>&apos;(&apos;</term>
					<term>&apos;df&apos;</term>
					<term>&apos;.&apos;</term>
					<term>&apos;columns&apos;</term>
					<term>&apos;[&apos;</term>
					<term>&apos;i&apos;</term>
					<term>&apos;] )&apos;] 2 Similar to Level 1</term>
					<term>but dots are allowed in tokens [&apos;for&apos;</term>
					<term>&apos;i&apos;</term>
					<term>&apos;in&apos;</term>
					<term>&apos;range&apos;</term>
					<term>&apos;(&apos;</term>
					<term>&apos;df&apos;</term>
					<term>&apos;.shape&apos;</term>
					<term>&apos;[&apos;</term>
					<term>&apos;1&apos;</term>
					<term>&apos;] ) :&apos;</term>
					<term>&apos;NEW˙LINE INDENT&apos;</term>
					<term>&apos;print&apos;</term>
					<term>&apos;(&apos;</term>
					<term>&apos;i&apos;</term>
					<term>&apos;) NEW˙LINE&apos;</term>
					<term>&apos;print&apos;</term>
					<term>&apos;(&apos;</term>
					<term>&apos;df&apos;</term>
					<term>&apos;.columns&apos;</term>
					<term>&apos;[&apos;</term>
					<term>&apos;i&apos;</term>
					<term>&apos;] )&apos;]</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Recent works have widely adopted large language model pretraining for source code, suggested source code-specific pretraining objectives and investigated the applicability of various Transformer-based language model architectures for source code. This work investigates another important aspect of such models, namely the effect of different subtokenization options, and aims at identifying most effective and length-efficient subtokenizations, taking into account code specifics. We propose subtokenziation that reduces average length by 17% without downstream performance drop, and show that a carefully chosen subtokenization may improve quality by 0.5-2%, possibly with some length increase.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>With the inspiration from the success of large language model (LM) pretraining in natural language processing (NLP), BERT-like models have been widely adopted for source code processing <ref type="bibr" target="#b9">(Feng et al., 2020;</ref><ref type="bibr" target="#b16">Kanade et al., 2020)</ref>, as code has a similar discrete sequential structure to natural text. Being trained on huge source code corpora in a self-supervised manner, large LMs often substantially outperform domain-specific models developed purposely for applied tasks, especially in the tasks with limited parallel / labelled data <ref type="bibr">(Ahmad et al., 2021a)</ref>. These tasks include fixing code bugs, generating text from code and vice versa, or translating code between programming languages.</p><p>Recent works advanced large LM pretraining on source code in two main directions. First, various model kinds were utilized for source code: CodeBERT <ref type="bibr" target="#b9">(Feng et al., 2020)</ref> and CuBERT <ref type="bibr" target="#b16">(Kanade et al., 2020)</ref> rely on the classic encoder-only RoBERTa <ref type="bibr" target="#b22">(Liu et al., 2019)</ref>, CodeGPT <ref type="bibr" target="#b23">(Lu et al., 2021)</ref> uses decoder-only GPT <ref type="bibr" target="#b26">(Radford &amp; Narasimhan, 2018)</ref>, PLBART <ref type="bibr">(Ahmad et al., 2021a)</ref> is based on the denoising sequence-to-sequence BART <ref type="bibr" target="#b20">(Lewis et al., 2020)</ref> model, and CodeT5 <ref type="bibr">(Wang et al., 2021b)</ref> utilizes multitask sequence-to-sequence T5 <ref type="bibr" target="#b28">(Raffel et al., 2020)</ref>. Second, a range of code-specific self-supervised pretraining tasks were proposed to enrich the classic masked language modeling (MLM) objective, e. g. <ref type="bibr">GraphCodeBERT (Guo et al., 2021)</ref> predicts data flow connections during pretraining (one variable is computed from another variable), and CodeT5 <ref type="bibr">(Wang et al., 2021b)</ref> and DOBF <ref type="bibr" target="#b31">(Roziere et al., 2021)</ref> use a variable naming objective. This work is devoted to investigating one more important component, subtokenization, which is usually not paid much attention when pretraining large LMs on source code. Modern LMs usually preprocess sequences using open-vocabulary models such as Byte-pair encoding <ref type="bibr">(BPE, Sennrich et al., 2016)</ref> which split long tokens into smaller subtokens. Though this process is often referred to as tokenization, we call it subtokenization, to underline its smaller granularity. Subtokenization became a standard part of all widely-used LMs pretrained on natural text or code, because it ensures the relatively high frequency of all subtokens (compared to the whitespace-separated tokenization, which results in a large portion of out-of-vocabulary tokens), at the same time producing sequences of reasonable length (compared to character-level tokenization). Though subtokenization was initially introduced for NLP, it is especially relevant for code, as programming languages usually permit identifiers of unrestricted complexity, e. g. variable or function names <ref type="bibr" target="#b5">(Chirkova &amp; Troshin, 2021)</ref>. Though subtokenization is often chosen with only superficial deliberation, it is one of the essential model components which may affect both quality and prediction speed. First, an inaccurately chosen subtokenization procedure may substantially increase sequence lengths and consequently slow down prediction. As a simple example, the work on CodeT5 <ref type="bibr">(Wang et al., 2021b)</ref> notices that using BPE trained specifically on source code corpora makes sequences 30-45% shorter than using BPE trained on natural text. Second, a line of recent research points at the positive effect of the carefully chosen subtokenization procedure on the model's performance in NLP. For example, <ref type="bibr" target="#b3">Bostrom &amp; Durrett (2020)</ref> show that using a UnigramLM <ref type="bibr" target="#b18">(Kudo, 2018)</ref> subtokenization algorithm instead of BPE improves the quality of BERT-based question answering or textual entailment in English by 1%, and <ref type="bibr" target="#b8">Ding et al. (2019)</ref> show that adjusting BPE vocabulary size in translation may produce +4 BLEU. At the same time, for large LMs, the particular subtokenization procedure chosen at the pretraining stage becomes an inseparable part of the model and must later be used in applied tasks. This underlines the need for a careful choice of subtokenization options when pretraining large LMs.</p><p>In this work, we conduct a deep study of subtokenization options for large LM pretraining on source code, using PLBART as a testing ground. In addition to investigating general aspects, e. g. the subtokenization algorithm and the vocabulary size, we study the ways of adapting subtokenization to the specific properties of code, such as a large amount of punctuation marks and frequentlyused token combinations, a variety of complex identifiers, or relative similarity of programming languages. We aim at choosing optimal subtokenization options that (a) lead to the best performance or (b) minimize sequence lengths (and thus speed up the model) without downstream performance drop. Our contributions are as follows -we show that for large LMs pretrained on source code:</p><p>• Grouping punctuation chars in single tokens reduces the average length by 17% without downstream performance drop (we call this approach CodeBPE or CodeUnigramLM), and permitting more complex composite tokens reduces lengths by 40%, sometimes with quality drop (Section 1); • UnigramLM is generally preferable over BPE (Section 4); • Smaller vocabularies may improve quality with 3-19% length increase (Section 5); • Subtokenizers are well transferable between programming languages (Section 6); Our length-efficient subtokenization procedure (see examples in Figure <ref type="figure" target="#fig_0">1</ref>) compresses sequences by 17% without quality drop and our most effective subtokenization improves performance by 0.5-2% significantly in three out of eight tasks and by one standard deviation in two other tasks.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">METHODOLOGY AND EXPERIMENTAL SETUP</head><p>The existing works on large LMs for source code usually choose a particular subtokenization library, for example the same as in the base LM the work uses, and train the subtokenizer with the vocabulary size of 30-50K on source code corpora used for pretraining. Often code is preprocessed before subtokenization, e. g. by replacing \n with NEW_LINE, and split into tokens on white-spaces and punctuation marks so that these tokens are further split into subtokens, e. g. for i in range (vocSize) will be split into <ref type="bibr">['for', 'i', 'in', 'range', '(', 'vocSize', '</ref>)'] even if for i in is generally a frequent combination. The latter principle appears to be intuitively reasonable, since it ensures that subtokenization preserves syntactically meaningful boundaries of tokens <ref type="bibr" target="#b16">(Kanade et al., 2020)</ref>. We refer to this principle as prohibiting composite tokens. More details on subtokenization in different LMs for code are given in Section 7.</p><p>We treat the described commonly-used approach as a baseline, and conduct a series of experiments, each modifying the baseline subtokenization procedure in one dimension and pretraining PLBART with the new subtokenization. The dimensions we vary are as follows: the allowed complexity of composite tokens, the subtokenization algorithm, the vocabulary size, the set of languages the subtokenizer is trained on, and the use of stochastic subtokenization. These dimensions are inspired either by the specifics of source code or by the recent works on subtokenization in NLP.</p><p>Experimental setup. As our base model, we use PLBART <ref type="bibr">(Ahmad et al., 2021a)</ref>, since it comes with the released pretraining code and data preprocessing routine under the MIT license. We use the same model size, the pretraining dataset size and other hyperparameter settings, including finetuning hyperparameters, as in PLBART<ref type="foot" target="#foot_0">foot_0</ref> . In particular, we use an encoder-decoder Transformer architecture with 6 layers in each part, with the model dimension of 768 and 12 heads (140M parameters). The pretraining data consists of 230M Python functions, 470M Java functions (crawled through BigQuery<ref type="foot" target="#foot_1">foot_1</ref> ) and 47M natural language (NL) descriptions (crawled from StackOverflow<ref type="foot" target="#foot_2">foot_2</ref> ), referred to as sequences below. The BigQuery dataset consists of repositories with clear open-source license. We pretrain all our PLBART models for 100k updates, as in the original paper.</p><p>As applied tasks, we consider three tasks from the PLBART paper: code generation (generating a Java function based on an NL description; CONCODE <ref type="bibr" target="#b14">(Iyer et al., 2018</ref><ref type="bibr">) dataset, CodeBLEU (Ren et al., 2020</ref>) metric), code summarization (generating an NL description for a Python or Java function; CodeSearchNet <ref type="bibr" target="#b13">(Husain et al., 2020)</ref> dataset, BLEU metric), code clone detection (classifying whether two Java functions implement the same functionality; BigCloneBench dataset <ref type="bibr" target="#b36">(Svajlenko &amp; Roy, 2015)</ref>; F1 metric), and one additional task of code translation (translating code from Python to Java and vice versa; AVATAR dataset <ref type="bibr">(Ahmad et al., 2021b)</ref>). Here we consider original data with the CodeBLEU metric (Code Translation-1) and the smaller version of data with tests and the Computational Accuracy metric -which portion of generated functions passed all tests (Code Translation-2). We chose tasks so that we have both code generative and discriminative tasks and that datasets are either in Python or Java.</p><p>We clip all sequences by 510 subtokens, except summarization where we clip by 250 subtokens following <ref type="bibr">Ahmad et al. (2021a)</ref>. Such clipping remains the majority of sequences unclipped in all subtokenizations: 96-99.1% in the pretraining data, 93-99% in translation, 88-100% in generation, 76-93% in summarization, and 37-80% in clone detection. In the main text we report average lengths computed on the randomly chosen subset of pretraining data before clipping, Appendix A reports length statistics for downstream data with similar trends as observed for the pretraining data. We only clip sequences passed to neural networks and use unclipped target sequences when computing metrics.</p><p>Baseline subtokenization. Following <ref type="bibr">Ahmad et al. (2021a)</ref>, we use a SentencePiece <ref type="bibr" target="#b19">(Kudo &amp; Richardson, 2018</ref>) library, which is a one of the most widely used solutions for subtokenization. We train subtokenizers on 10M functions and NL descriptions randomly selected from the pretraining data (different from the random subset on which we measure average lengths). Though <ref type="bibr">Ahmad et al. (2021a)</ref> use BPE subtokenization algorithm, our baseline subtokenization uses another algorithm, UnigramLM, because it was shown to be quantitatively and qualitatively more suitable for pretraining in NLP than BPE <ref type="bibr" target="#b3">(Bostrom &amp; Durrett, 2020)</ref>. We also perform their comparison for code in Section 4. We set the vocabulary size to 50K (the commonly used size for large LMs of code) and character coverage to 99.99% (enough to cover English chars and punctuation).</p><p>We also use PLBART's preprocessing which includes removing comments and docstrings, replacing \n, indents and dedents in Python with NEW_LINE, INDENT and DEDENT tokens as they are a part of the language syntax, and removing formatting in Java as it does not affect the language syntax. Our baseline subtokenizer follows the commonly used strategy of prohibiting composite tokens described above. The only exception we make is that we allow underscores _ inside tokens, because they do not represent a syntax unit, as other punctuation chars do.</p><p>Table <ref type="table">1</ref>: Different levels of allowed composite tokens complexity considered in the paper. Green emphasizes tokens which could not be obtained in the previous level, and gray emphasises the remaining tokens that could not be obtained in Level 0. Levels list allowed merges, but what particular merges to perform is chosen by the tokenizer.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Lev. Description Example 0</head><p>Whitespaces in the middle of tokens are prohibited and each punctuation char is treated as a separate token (except '_') <ref type="bibr">['for', 'i', 'in', 'range', '(', 'df', '.', 'shape', '[', '1', ']</ref>', ')', ':', 'NEW_LINE', ' <ref type="bibr">INDENT', 'print', '(', 'i', ')', 'NEW_LINE', 'print', '(', 'df', '.', 'columns', '[', 'i', ']</ref> </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">SUBTOKENIZATION GRANULARITY</head><p>In natural text, a portion of punctuation chars is small and thus their separation in subtokenization does not affect lengths much. In contrast, in source code, punctuation constitutes 12.8% of chars and often forms frequent combinations joining which into composite tokens may substantially reduce lengths. Further, the presence of a large amount of commonly used patterns is another specific feature of source code, e. g. for (int i = 0; in Java or def __init__ (self): in Python, and these patterns again may form composite tokens. This section investigates the effects of the use of composite tokens on performance and length-efficiency.</p><p>We consider several levels of allowed complexity of composite tokens listed in Table <ref type="table">1</ref> and empirically compare them in Figure <ref type="figure" target="#fig_1">2</ref>. The two extreme cases are no composite tokens (Level 0, equal to the baseline subtokenization) and unrestricted composite tokens complexity (Level 4, composite tokens constitute 48.6% of the vocabulary). The average sequence length in Level 4 is 40% less than that in Level 0. At the same time, the effect on performance depends on the task: in code-generative tasks (translation and generation), Level 4 performs significantly worse than Level 0, and in code understanding tasks, Level 4 is either similar / marginally worse than Level 0 (code summarization) or even significantly better (clone detection). Because of quality loss encountered in several tasks, we consider intermediate levels.</p><p>Level 1 makes one step further from Level 0 and allows punctuation char merges, e. g. '})' or ']):'. Though such punctuation composite tokens constitute only 3.4% of the vocabulary, their use reduces average length by 17%: from 97 to 80.7, and since this level does not mix punctuation with other chars, it presumably should not complicate code generation much. Level 2 makes one more step further and allows merging dots . with textual tokens. This reduces the average length by 23% compared to Level 0. The motivation for Level 2 is that a lot of API name tokens almost always go with the dot, e. g. .join or .split in Python. Figure <ref type="figure" target="#fig_1">2</ref> shows that Level 1 model performs similar or better than Level 0 model in all tasks, and Level 2 performs similar or better than Level 0 in six tasks, marginally worse in Python code summarization and significantly worse in Java code generation.</p><p>Level 3 makes a step back from Level 4 and restricts the complexity of composite tokens in such a manner that each composed token may represent either a simple one-line code pattern or a punctuation combination, but could not combine them. Quantitatively, Level 3 performs generally better than Level 4, but (marginally or significantly) worse than the previous Level 2 in six tasks and similarly in two tasks (generation and clone detection).</p><p>To sum up, punctuation combinations (Level 1) result in sequence lengths reduction by 17% without performance drop in all tasks. We verify this result for BPE in Appendix B and call this approach CodeBPE or CodeUnigramLM. Length reduction could be increased up to 24% in most tasks by allowing dots attached to tokens (Level 2) and up to 40% in most code understanding tasks by allowing arbitrary subtoken combinations (Level 4). we investigate the transferability of subtokenizers between programming languages in Section 6.</p><p>One of the potential issues with using composite tokens in code-generative tasks is that an inaccurate generation of a "long" token may change the entire following generated code. For example, in Java-Python code translation, a cycle which traverses all unique element pairs in an array, converts to for l in range ( 0 , arr_size -1 ) : for r in range ( l + 1 , arr_size ) :</p><p>While the Level 0 model generates exactly the specified cycle and the Level 1 model only modifies the first cycle: range ( arr_size -1 ), making it even more concise, Level 3 model generates for l in range ( 0 , arr_size ) : for r in range ( 0 , arr_size ) :</p><p>which results in traversing some elements twice. Here the first cycle begun with tokens 'for l in' and 'range ( 0 ,' and the second cycle begun with tokens 'for r in' and 'range ( 0 ,' where the latter repeats the previously used token and starts an incorrect line. However, according to our manual prediction analyses, such inaccurate generation, if it happens, rarely results in wrong code and often does not affect code semantics. For example, the Level 3 model may generate ['range ( 0 ,', 'n )'] instead of equivalent range(n). Another example is that this model may generate [ [ 0 ] * c for i in range ( r ) ] instead of two nested cycles by beginning with tokens '[ [' and '0 ] * ', resulting in even more concise code.</p><p>As for composite tokens in Level 1, they contain only punctuation and are "simpler" than in Level 3. Besides, Level 1 composite tokens serve more often for statement closing (e. g. ')):' at the end of the cycle specification) than for a harder starting of new statements: 46.3% of Level 1 composite tokens contain only closing brackets, 12.8% contain only opening brackets and 26.7% contain both. We also check that using punctuation composite tokens does not deteriorate syntactic correctness: in Java-Python code translation-1, Level 0 and Level 1 models generate a similar number of syntactically correct test code snippets: 1226 and 1239 correspondingly. At the same time, for the Level 3 model, this quantity only equals 1163.</p><p>In Appendix C, we also analyse how much do input and output subtoken sequences intersect in different Levels and find that generally the higher granularity leads to the lower intersection rate. This may be another explanation for the superiority of the lower granularity subtokenizations, as intuitively it should be easier for the model to predict correct subtokens if they are present in the input sequence.</p><p>As aurogregressive decoding is a slowest part of the encoder-decoder pipeline <ref type="bibr" target="#b2">(Berard et al., 2021)</ref>, it is important to check that the length statistics of sequences generated by the models comprising composite tokens are close to those of the data. We check it for Java-Python translation-1: while groundtruth sequences at Levels 1 and 3 are 13.5% and 50% shorter than at Level 0, the generated sequences at these levels are 15% and 40% shorter than sequences generated at Level 0.</p><p>45 46 BPE 50K UniLM 50K UniLM 10k UniLM 2k 98 Clone detection (Ja, F1) BPE 50k 50k UniLM 10k 2k 0 50 100 150 97.1 97.0 106.3 130.1 Av. length  We note that though we use sequence clipping which clips lower granularity subtokenizations stronger, it does not devalue our results, as generally lower granularity subtokenizations perform better in our experiments, and also such clipping is a widely used practical scenario; we provide more comments in Appendix C. At the same time, in rare cases when lower granularity subtokenizations perform worse than higher granularity ones, this may be indeed due to the max-length clipping. For example, we find that the more "fair" cropping eliminates the superiority of Level 1 compared to Level 0 in code summarization and they start performing similarly (see Appendix C).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">SUBTOKENIZATION ALGORITHM</head><p>Bostrom &amp; Durrett (2020) compare two most popular subtokenization approaches, BPE and Uni-gramLM <ref type="bibr" target="#b18">(Kudo, 2018)</ref>, for pretraining of large LMs on natural text data. While BPE constructs the vocabulary in the bottom-up fashion, starting from characters and gradually joining them, the Un-igramLM algorithm works in the top-down fashion, staring from a large vocabulary and gradually filtering it. The paper finds that UnigramLM outperforms BPE in a range of downstream tasks and suggests several reasons for the superiority of UnigramLM, including better alignment with morphology and the more efficient vocabulary allocation. Since most existing pretrained LMs on source code use BPE, we decided to compare the two algorithms for source code.</p><p>Figure <ref type="figure" target="#fig_2">3</ref> compares BPE and UnigramLM for PLBART. In three tasks, UnigramLM outperforms BPE by one standard deviation, and in remaining tasks their performance is very close. Since the average length of two tokenizations is similar, we recommend using UnigramLM for source code.</p><p>Bostrom &amp; Durrett (2020) argue that one of the potential reasons for the superiority of UnigramLM subtokenization is that it is better aligned with natural text morphology and thus simplifies the composition of words by parts. We find that a similar effect appears for identifiers in source code: although 80% of identifiers are subtokenized identically by UnigramLM and BPE, for some of the remaining 20%, UnigramLM provides more "reasonable" splits into subtokens, see examples in Table 2. More formally, we observe that UnigramLM subtokenization better resembles splitting into subtokens based on CamelCase or snake_case, which we call a native subtokenization. To estimate this effect quantitatively, we consider the Python corpus and randomly select a set of 150K identifiers with different UnigramLM and BPE subtokenizations consisting of ⩾ 2 native subto-kens, and measure the average Jaccard similarity J(A, B) = |A ∩ B|/|A ∪ B| between the set of native subtokens and the set of subtokens produced by each subtokenizer. The resulting score for UnigramLM, 26.6%, is much higher than for BPE, 15.2%. As could be observed from the third and the fourth rows in Table <ref type="table" target="#tab_1">2</ref>, sometimes subtokenizers join two native subtokens into one (isSame, GridBag). If we split each subtoken produced by a tokenizer based on CamelCase or snake_case to eliminate this effect and again measure average Jaccard similarities, UnigramLM's score, 55.2%, is still much higher than BPE's, 47.9%, again indicating that UnigramLM's tokenization is better aligned with the native one. In Appendix C we measure intersections between inputs and outputs in the sequnce-to-sequence tasks and find that UnigramLM leads to a slightly higher intersection rate than BPE, which may be connected to the better alignment with native subtokenization and serve as a a possible explanation of UnigramLM slight performance superiority.</p><p>A relatively frequent pattern is that BPE tends to detach the first uppercase letter from native subtokens (H orizontally in row 4, _H ierarchy in row 5). Among 150K identifiers considered in the previous paragraph, 14.6% of BPE tokenizations contain at least one single uppercase letter X and 4.4% -at least one subtoken of kind _X, while for UnigramLM these scores are substantially lower and equal to 11.8% and 1.4% correspondingly. At the same time, BPE merges two native subtokens more frequently (GridBag in row 3): 45.8% BPE tokenizations contain at least one token which could be split into two or more based on CamelCase, while for UnigramLM this score only equals to 39.2%.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">VOCABULARY SIZE</head><p>This section studies the effect of vocabulary size, one of the main subtokenizer's hyperparameters, on the downstream quality of PLBART. Though the existing pretrained LMs for code use relatively large vocabularies of 30-50K tokens, we are interested, whether using smaller and less lengthefficient vocabularies could result in better performance, and if yes, how large is the length increase.</p><p>Figure <ref type="figure" target="#fig_2">3</ref> presents the comparison of PLBARTs trained with vocabulary sizes 50K (large), 10K (medium) and 2K (small). We find that in code translation, all vocabularies lead to similar performance. In code summarization, small and medium vocabularies outperform the large one by one standard deviation. In code generation, the medium vocabulary significantly outperforms the large one. Finally, in clone detection, decreasing the vocabulary size deteriorates quality. At the same time, with the large vocabulary, sequences are shorter than with the smaller vocabulary by 9.5% (10K) and 33% (2K), but the model size is larger (139M for 50K, 108M for 10K, and 102M for 2K). We conclude that vocabulary size reduction may lead to a slight performance improvement but with sequences elongation, thus it may be helpful in applications with high cost of errors and weak restrictions on sequences lengths. We verify the highlighted result for BPE in Appendix. We note that compared to BPE 50K which is used in most existing large LMs of code, UnigramLM 10K improves performance significantly in three tasks and by one standard deviation in two other tasks.</p><p>Reducing vocabulary size increases the granularity of identifiers subtokenization, e. g. reachable is subtokenized as reachable with the 50K vocabulary, reach able -with 10K and re ach able -with 2K. In other words, vocabulary size reduction may be seen as an even stronger prohibition of complex tokens than Level 0 in Section 1. Our results on the effectiveness of smaller granularity agree with the machine translation results of <ref type="bibr" target="#b8">Ding et al. (2019)</ref>. Programs in code generation and summarization data are more identifier-centered, e. g. the model often needs to choose a correct API based on the natural language description which seems to be easier by composing from smaller subtokens. On the contrary, in code translation, data is more algorithmic-centered, with mostly short identifiers encoded in 1-2 subtokens with all vocabulary sizes. The length increase of 10K vocabulary compared to 50K one is 6-19% in the former two tasks (6% in generation, 19% in summarization) and only 3.5% in the latter one (code-translation-1).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">TRANSFERABILITY BETWEEN PROGRAMMING LANGUAGES</head><p>Due to the high computational cost of large LM pretraining and relative programming languages similarity, e. g. compared to how dissimilar natural languages could be, pretrained LMs on source code are often used for programming languages that were not considered during pretraining. In this section, we investigate the effect of using a subtokenizer trained on one programming language for another programming language.</p><p>10 9 10 8 10 7 10 6 10 5 10 4 10 3 10 2 Frequency in Java 10 9 10 8 10 7 10 6 10 5 10 4 10 3 10 2 Frequency in Python Level 0 granularity 10 9 10 8 10 7 10 6 10 5 10 4 10 3 10 2</p><p>Frequency in Java Figure <ref type="figure" target="#fig_4">4</ref> visualizes the number of tokens having particular frequencies in Python and Java languages, and black rectangles denote language-specific areas. We find that the baseline Level 0 granularity vocabulary seems to be language-universal: the majority of subtokens have large frequencies in both languages, and only a small number of subtokens, 12.6%, are frequent in one language and rare in another. Interestingly, for Level 4 vocabulary, this quantity is not much higher, 20.1%, though it should include all language-specific composite tokens. As composite tokens occupy almost half of the Level 4 vocabulary, the remaining 30% composite tokens are common for two languages.</p><p>Analysing sequence lengths (Figure <ref type="figure" target="#fig_3">5</ref>), we observe that training the subtokenizer without Java (Only Py) shortens Python sequences marginally and increases Java sequences by 6.5% compared to the baseline subtokenizer trained on all data (Py+Ja). The latter happens because some widely used Java identifiers were not merged into single tokens as they are not used in Python; still, the length increase is not so large. For the Level 4 granularity subtokenizer, Only Py's length increase on Java is larger, 13%, since it contains more language-specific composite tokens. However, due to common composite tokens, the resulting Level 4 Only Py's Java average length is still smaller than Level 1 Only Py's Java sequences: 79 vs. 83.</p><p>As for performance, using the Only Py subtokenizer instead of Py+Ja changes quality up to one standard deviation and could both increase and decrease it on Java data (quality increase may be caused by the increased subtokenization granularity). Note that we only change subtokenizer configuration -PLBART is still pretrained on all languages, this may happen in practice if LM's developers use the subtokenizer from another project, e. g. for comparison purposes. Summing up, we conclude that the baseline subtokenizer is universal and, if needed, could be used for other programming languages it was not trained on, with small length increase and slight quality change. We note that Python and Java have quite different syntax and are usually used in different applications.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">RELATED WORK</head><p>Subtokenization studies for NLP. Subtokenization has become an essential component of modern NLP pipelines and thus -a subject of a line of empirical NLP studies. While word-based models suffer from the out-of-vocabulary problem, subtoken-based (open-vocabulary) as well as char-based approaches cover arbitrary novel words. Among various open-vocabulary approaches, BPE <ref type="bibr" target="#b34">(Sennrich et al., 2016)</ref>, WordPiece <ref type="bibr" target="#b41">(Wu et al., 2016)</ref> and UnigramLM <ref type="bibr" target="#b3">(Bostrom &amp; Durrett, 2020)</ref> became most widely used, and UnigramLM was shown to outperform BPE for LM pretraining <ref type="bibr" target="#b3">(Bostrom &amp; Durrett, 2020)</ref>. A line of studies investigate the optimal granularity of word subtokenization: <ref type="bibr" target="#b8">Ding et al. (2019)</ref> find that in Transformer-based neural machine translation, small vocabularies of 0-4K subtokens outperform large ones by up to 4 BLEU, and VOLT <ref type="bibr">(Radford et al., 2018)</ref> automates the search of a proper subtoken vocabulary with a proper size by formulating it as an optimal transport problem. The smallest char-based granularity is often avoided because of substantial sequences elongation, but has particular strengths, e. g. much less number of hyperparameters and better robustness, and thus appears to be a promising research direction <ref type="bibr" target="#b12">(Gupta et al., 2019;</ref><ref type="bibr" target="#b7">Clark et al., 2021;</ref><ref type="bibr" target="#b37">Tay et al., 2021)</ref>. <ref type="bibr" target="#b25">Provilkov et al. (2020)</ref>; <ref type="bibr" target="#b18">Kudo (2018)</ref> propose stochastic subtokenization as a way to improve new words composition and <ref type="bibr">(Wang et al., 2021a)</ref> adapt it to pretrained LMs. Finally, an actively studied challenge is that various natural languages need different subtokenization decisions and are hard to subtokenize with one common model <ref type="bibr" target="#b6">(Chung et al., 2020;</ref><ref type="bibr" target="#b32">Rust et al., 2021)</ref>. Our work investigates most of the specified directions for source code. For a more detailed review on subtokenization, see <ref type="bibr" target="#b24">(Mielke et al., 2021)</ref>.</p><p>Subtokenization practices in neural source code processing. Subtokenization was first tested for source code in <ref type="bibr" target="#b17">(Karampatsis et al., 2020)</ref> and later used in the majority of Transformer-based models. Almost all LMs pretrained on source code use BPE-like subtokenization with large vocabulary: CodeBERT uses the WordPiece (Wu et al., 2016) algorithm (a modified BPE, 50K), CuBERTan algorithm from the Tensor2Tensor project (Vaswani et al., 2018) (50K), PLBART and CodeGPT -BPE (50K), CodeT5 -byte-level BPE (32K), DOBF uses a subtokenization procedure of either CodeBERT or Roziere et al. (2020) (BPE 64K) for fair comparison, AlphaCode Li et al. (2022) -SentencePiece (8K, algorithm not specified), InCoder Fried et al. (2022) -BPE (50K). To the best of our knowledge, existing works do not provide an in-depth experimental analysis of various subtokenization options for code and, particularly, do not investigate various levels of composite tokens complexity. Though the concurrent work of Fried et al. ( <ref type="formula">2022</ref>) uses unrestricted composite tokens (our Level 4), they do not compare them to any other subtokenizations. Level 4 composite tokens are conceptually similar to code idioms used in <ref type="bibr" target="#b15">(Iyer et al., 2019;</ref><ref type="bibr" target="#b35">Shin et al., 2019)</ref> for code generation, but the mentioned works develop specific procedures for mining idioms, which need separate implementation, while we rely on the commonly-used subtokenization procedure.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">CONCLUSION</head><p>In this work, we conducted an empirical study of varying subtokenization options for large LMs pretraining on source code. We believe that main the value of our work is not in improved numerical criteria, but importantly in providing reference experiments for the community showing which impact (both substantial or small) subtokenization choices may have in pretraining LMs for code. This underlines which directions to look more carefully at in practice (the use of composite tokens) and which are less important to experiment with (vocabulary size, subtokenization algorithm), and whether the later directions can bring at least a slight improvement or not (yes, they can). Currently most works experiment with subtokenizations options only superficially or do not experiment at all, and we hope that our work will provide motivation to do that.</p><p>Our recommendations. As for particular direct recommendations from our results, first, we recommend to use the proposed punctuation combination approach, which we call CodeBPE or Code-UnigramLM depending on the used subtokenization algorithm, that shortens sequences by 17% without quality drop. We suppose that with larger pretrained LMs higher levels of composite tokens may also achieve comparable performance; we were not able to experiment with then as they require very extensive computational resources. Second, if changing the subtokenization algorithm is easy, e.g. when using the SentencePiece library, we recommend using the UnigramLM, since it performs slightly better than commonly used BPE with similar lengths. Third, we recommend considering releasing models with smaller vocabularies, as they may perform slightly better than larger vocabularies. In our experiments the UnigramLM-10K subtokenizer was 0.5-2% more effective than the commonly-used BPE 50K in 5/8 experiments, but with 3.5-19% length increase.</p><p>Limitations The main work's limitation is that we consider only the PLBART model, due to the limited computational resources. However, we believe that the provided recommendations will motivate and simplify the process of the subtokenizer's tuning for future works, as described above.</p><p>Another limitation is that we focus on finding optimal subtokenization options only for source code, though some downstream tasks also include the processing of natural language. Investigating the ways of choosing optimal subtokenization for both code and natural language may be an interesting direction for future research. Finally, we only compare BPE and UnigramLM, while it could be interesting to investigate the performance of other algorithms, e. g. WordPiece.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>BROADER IMPACT</head><p>We do not anticipate any direct negative social impact of our work. However, our results may potentially be used for developing new pretrained LMs for source code, and a detailed discussion on their broader impact is provided in Chen et al. ( <ref type="formula">2021</ref>) (Section 7), e. g. over-reliance on generated code or producing vulnerable code. Unfortunately, our work may cause negative environmental impact because of computation (∼5K Tesla A-100 GPU hours and ∼4K Tesla V-100 GPU hours at the internal cluster).</p><p>that longer (less compact) subtokenizations, most affected by clipping, generally perform better than shorter (more compact) subtokenizations which allow less information loss. Using the more "fair" setting may make the performance of more compact subtokenizations worse (and not affect less compact subtokenizations), amplifying performance differences further.</p><p>In this section, we conduct such a "fair" experiment for three representative downstream tasks and crop subtoken sequences produced by all subtokenizers so that they are all detokenized into a similar character sequence. In the example above, the 2K subtokenization will stay unchanged while the Level 4 subtokenization will be cropped into ['x =', 'sum ('] to achieve equality. The results are shown in Figure <ref type="figure">7</ref>. Comparing the observations to the hypothesis given above, we observe that the performance of smaller vocabulary subtokenizations, less affected by cropping, stays similar (as expected) and that the performance of higher granularity subtokenizations, most affected by cropping, often reduces (Levels 0 and 1 in translation, Level 1 in summarization) or stays similar (Level 0 in summarization, Level 1 in clone detection), again as we expected. Surprisingly, in some cases (Level 4 in all tasks and Level 0 in clone detection), the performance of higher granularity subtokenizations improve slightly after cropping. We hypothesize that the reason may be that the last parts of sequences may be not important for correct prediction, e. g. if __name__ == "__main__" statements in Python translation examples may be auxiliary and not used during translation.</p><p>As for the conclusions emphasized in the main text, they hold for the cropped setting as well: (a) the marginal performance superiority of smaller vocabularies compared to the Level 0 50K vocabulary, is amplified (translation) or similar (summarization) as in the main text; (b) the relative performance of Level 0 and Level 4 is similar as in the main text; (c) the observation that the Level 1 subtokenization performs not worse than the Level 0 subtokenization stays same as in the main text.</p><p>Interestingly, in Java code summarization, Level 1 subtokenization performs slightly better than Level 0 subtokenization in the main text, while after cropping their performance is similar. We thus attribute the superiority of Level 1 in the main text to the less strong clipping than of Level 0 subtokenizations.</p><p>44 45 46 2K 10K Level 0 Level 1 Level 4 Code transl.-1 (Py, CodeBLEU) 18.50 18.75 19.00 19.25 19.50 Code summ. (Ja, BLEU) 96.5 97.0 97.5 98.0 98.5</p><p>Clone detection (Ja, F1)</p><p>Figure <ref type="figure">7</ref>: Additional experiments with subtoken sequences being cropped so that for each datapoint, the subtoken sequences produced by all subtokenizers are detokenized into a similar character sequence. Effectively this cropping means that the 2K subtokenizer's sequences stay unchanged while all others may be cropped, and the Level 4 subtokenizer's sequences are cropped the most. Blurred bars visualize original performance reported in the main paper, with "unfair" clipping used in practice. Both 2K and 10K subtokenizations use Level 0 preprocessing and all Level X subtokenizations use the 50K vocabulary, all experiments with UnigramLM.</p><p>How much do input and output sequences intersect for various subtokenizations? In attempt to better understand the effect of subtokenizations on downstream performance, we measure the Jaccard similarity J(A, B) = |A ∩ B|/|A ∪ B| between the sets of input and output subtokens in sequence-to-sequence tasks. The intuition is that it should be easier for the model to predict correct subtokens if they are present in the input sequence. We only include textual subtokens in the considered sets (subtokens which do not include any programming language punctuation), since "copying" subtokens which include punctuation seems to be unrealistic (in text-to-code or codeto-text tasks, the text part does not include programming language punctuation at all, and in the translation task, punctuation of Python and Java are very dissimilar). We consider the setting with "fair" cropping described in the previous paragraph, however for the conventional setting the results are similar.</p><p>The results are presented in Table <ref type="table" target="#tab_5">5</ref>. The general trend that the higher the granularity, the lower the intersection rate, appears to be reasonable. For example, we observe the explainable monotonic decrease in intersection for 2K-10K-50K vocabularies: the smaller the vocabulary, the smaller the granularity of identifiers/words subtokenization, the more chance that different parts of words will repeat. This correlates with our empirical observation that generally smaller vocabulary sutokenizations perform slightly better.</p><p>Interestingly, Level 1 subtokenization leads to a slightly higher intersection rate than Level 0. We explain it that punctuation combinations occupy a portion of vocabulary (3.4%) and thus reduce the effective vocabulary allocated for textual tokens, which will be slightly more often split into parts. This effect shows that if one has some "length budget", it is better to be spent on splitting identifiers into subtokens rather than considering punctuation chars as separate tokens (they can be grouped).</p><p>For further levels, two forces start competing: the first one that composite tokens occupy a part of the vocabulary and thus out-of-vocabulary identifiers are split into smaller pieces that are repeated relatively frequently, and the second one that composite tokens themselves are longer and are repeated rarely between input and output. The second force is absent for Level 1 considered above because Level 1 composite tokens are punctuation-only and do not include letters or digits. We observe that for Level 2, the first force outweighs the second one in translation and summarization (intersection rate is higher than for Levels 0 and 1) and underweights in generation (intersection rate lower than in Levels 0 and 1). Interestingly, this correlates with performance of Level 2 compared to Levels 0 and 1: it is on par with them in translation and summarization and lower in generation. Further on, at Levels 3 and 4 the intersection rate drops, with small increase of Level 4 compared to Level 3, explainable by the specifics of Level 3 construction focused on programming statements.</p><p>Finally, we compare the intersection rate of UnigramLM and BPE (both Level 0, 50K) and find that in summarization and generation it is slightly higher for UnigramLM than for BPE and in translation they are equal. This observation complements our findings that UnigramLM subtokenizations are better aligned with native subtokenizations than BPE subtokenizations and provides some intuition how it matters (similarity to native subtokenization presumably increases the number of repeated subtokens which should be easier to correctly predict). Subtoken frequences visualization. In Figure <ref type="figure">8</ref>, we visualize subtoken frequencies computed over 1/8 of the pretraining corpora for four subtokenizers: UnigramLM Level 0 50K, BPE Level 0 50K, UnigramLM Level 1 50K and UnigramLM Level 4 50K. Comparing UnigramLM and BPE, we find that UnigramLM has a slightly heavier tail which results in a greater number of subtokens having higher frequncies and thus better embeddings, the similar observation was also noticed in <ref type="bibr" target="#b3">Bostrom &amp; Durrett (2020)</ref>. The frequency profiles of Level 0 and Level 1 subtokenizers are close. Level 4 vocabulary exhibits less contrast in frequencies than Levels 0 and 1: in the left range, Level 4 frequencies are lower, while in the right range, Level 4 frequencies are higher, which hypothetically could provide some advantage to Level 4 (but it does not, according to the reported performance results). We hypothesize that having high frequencies in the left range is important for high performance (more reliable "basic" subtokens) but high granularity subtokens reduce frequencies of smaller subtokens which negatively affects their embeddings.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>D NUMERICAL RESULTS</head><p>Table 6 presents the numerical results for figures in the main text and Appendix B.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: Example subtokenizations (all numbers compared to the commonly used BPE-50K).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: Results on various subtokenization granularity, averaged over 4 finetuning runs (mean ± standard deviation). Level 0 -baseline subtokenization. Numerical data for all plots is given in Appendix.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: Comparison of BPE and UnigramLM subtokenizers and of several vocabulary sizes. Uni-gramLM 50K -baseline subtokenization.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 5 :</head><label>5</label><figDesc>Figure 5: Results of transferability between programming languages. Py+Ja -subtokenizer is trained on all data (baseline), Only Py -on Python and natural language data only.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: Number of tokens of different frequency in two languages, Uni-gramLM 50K vocabularies.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table 2 :</head><label>2</label><figDesc>Example subtokenization of identifiers by UnigramLM and BPE subtokenizers</figDesc><table><row><cell>Original token</cell><cell cols="2">UnigramLM subtok-</cell><cell cols="3">BPE subtokenization</cell><cell cols="3">Native subtokenization</cell></row><row><cell></cell><cell>enization</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell cols="3">(Camel-or snake case)</cell></row><row><cell cols="2">fromDottedString ['from',</cell><cell>'Dotted',</cell><cell>['from',</cell><cell>'Dot',</cell><cell>'ted',</cell><cell cols="3">['from', 'Dotted', 'String']</cell></row><row><cell></cell><cell>'String']</cell><cell></cell><cell>'String']</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>isInstantiated</cell><cell cols="2">['is', 'Instantiate', 'd']</cell><cell cols="3">['isIn', 'stanti', 'ated']</cell><cell cols="3">['is', 'Instantiated' ]</cell></row><row><cell cols="2">GridBagConverter ['Grid',</cell><cell>'Bag',</cell><cell cols="3">['GridBag', 'Converter']</cell><cell cols="3">['Grid', 'Bag', 'Converter']</cell></row><row><cell></cell><cell>'Converter']</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>isSameSize</cell><cell>['isSame',</cell><cell>'Size',</cell><cell>['isSame',</cell><cell>'Size',</cell><cell>'H',</cell><cell>['is',</cell><cell>'Same',</cell><cell>'Size',</cell></row><row><cell>Horizontally</cell><cell>'Horizontally']</cell><cell></cell><cell cols="2">'orizontally']</cell><cell></cell><cell cols="2">'Horizontally']</cell><cell></cell></row></table><note><p>PA_Hierarchy_ID</p><p>['PA', '_', 'Hierarchy', '_ID'] ['PA', '_H', 'ierarchy', '_ID']</p><p>['PA', '_', 'Hierarchy', '_', 'ID']</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head>Table 5 :</head><label>5</label><figDesc>Average Jaccard similarities between the sets of input and output textual subtokens, for different subtokenizations. All subtokenizations expect the last one use the UnigramLM algorithm; Base ans Level 1-4 subtokenizations use vocabulary of 50K; 10K and 2K subtokenizations are based on Level 1 preprocessing.</figDesc><table><row><cell></cell><cell>2K</cell><cell cols="6">10K Level 0 Level 1 Level 2 Level 3 Level 4</cell><cell>BPE</cell></row><row><cell cols="3">Code trans. (Py) 14.61 13.91</cell><cell>13.68</cell><cell>13.81</cell><cell>14.38</cell><cell>6.65</cell><cell cols="2">7.79 13.67</cell></row><row><cell>Code gen. (Ja)</cell><cell cols="2">11.65 10.51</cell><cell>9.57</cell><cell>9.61</cell><cell>8.94</cell><cell>4.70</cell><cell>6.51</cell><cell>8.88</cell></row><row><cell>Code sum. (Ja)</cell><cell>10.25</cell><cell>7.26</cell><cell>5.99</cell><cell>6.03</cell><cell>6.33</cell><cell>2.84</cell><cell>5.80</cell><cell>5.67</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>https://github.com/wasiahmad/PLBART</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_1"><p>https://console.cloud.google.com/marketplace/details/github/ github-repos</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_2"><p>https://archive.org/download/stackexchange</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div><head>ACKNOWLEDGMENTS</head><p>The results were supported by the <rs type="funder">Russian Science Foundation</rs> grant <rs type="grantNumber">№19-71-30020</rs>. The research was supported in part through the computational resources of HPC facilities at NRU <rs type="institution">HSE</rs>.</p></div>
			</div>
			<div type="funding">
<div><p>Whitespaces and single punctuation chars allowed in tokens, except <rs type="institution">NEW_LINE ['for i in range', '( df', '. shape [ 1', '] ) :', 'NEW˙LINE INDENT', 'print', '( i', ') NEW˙LINE', 'print', '( df', '. column', 's [ i', '] )'] 4 Composite tokens of arbitrary complexity are allowed ['for i in range', '( df', '. shape', '[ 1 ]', ')', ': NEW˙LINE', 'INDENT print', '( i )', 'NEW˙LINE print', '( df', '. columns', '[ i ] )</rs>']</p></div>
			</div>
			<listOrg type="funding">
				<org type="funding" xml:id="_JKE6qxR">
					<idno type="grant-number">№19-71-30020</idno>
				</org>
			</listOrg>

			<div type="availability">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Code transl.-1 (Py, CodeBLEU) 64 66 68 Code transl.-2 (Py, Comp. Acc.) 19.0 19.5 20.0 Code summ. (Py, BLEU) 37 38 39 Code gen. (Ja, CodeBLEU) 47 48 49 BPE 50K UniLM 50K UniLM 10k UniLM 2k Code transl.-1 (Ja, CodeBLEU) 56 58 Code transl.-2 (Ja, Comp. Acc.) 18.5 19.0 19.5 Code summ. (Ja, BLEU) 97 Published as a conference paper at ICLR 2023 45.5 46.0 46.5 Py+Ja Only Py Code transl.-1 (Py, CodeBLEU) 65 70 Code transl.-2 (Py, Comp. Acc.) 19.50 19.75 Code summ. (Py, BLEU) 38.0 38.5 Code gen. (Ja, CodeBLEU) 47 48 49 Py+Ja Only Py Code transl.-1 (Ja, CodeBLEU) 56 58 Code transl.-2 (Ja, Comp. Acc.) 18.5 19.0 Code summ. (Ja, BLEU) 97.5 98.0 Clone detection (Ja, F1)</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A AVERAGE LENGTHS ON THE FINETUNING DATA</head><p>In the main text, we report average lengths computed over a randomly chosen subset of the pretraining data (different from the random subsets subtokenizers were pretrained on). Table <ref type="table">3</ref> reports average lengths computed over finetuning data, we also include average lengths computed over held-out pretraining data. For programming languages, we observe similar trends as on the general pretraining data: Level 1 compresses sequences by 11.6-17.7% (the lower compression in the code summarization task, 11.6-12.8%, is explained by the higher percent of identifiers in this data than in other tasks); Level 4 compresses sequences by 32.4-50%; and 2K vocabularies increase lengths by 3.5-10.2% and 12.7-35.9% respectively; and BPE and UnigramLM average lengths are similar.</p><p>As for natural text, its average lengths are not affected by the Level 1 subtokenization because it only affects punctuation char sequences, rarely present in the natural language data. At the same time, higher level subtokenizers may produce natural language subtoken sequences of higher lengths, because their vocabularies are occupied by programming-focused composite tokens rarely present in natural language data, while frequent words may be absent in these vocabularies. Small vocabulary subtokenizers also have programming language-focused vocabularies, resulting in higher lengths increase for natural text than for programming languages.</p><p>In Table <ref type="table">4</ref>, we report time needed to generate predictions for the test set in two tasks. The measurement was conducted on a single Tesla V100 GPU, in the same session for all runs. The speed-up is stronger than the length decrease, because of quadratic Transformer complexity.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B ADDITIONAL EXPERIMENTS WITH BPE</head><p>Figure <ref type="figure">6</ref> presents the comparison of BPE Level 0 and Level 1 subtokenizations and of BPE 50K and 10K vocabularies. The results are similar to those of UnigramLM reported in the main text: the performance of Level 0 and Level 1 subtokenizations is again close, the model with 10K vocabulary again significantly outperforms the model with 50K vocabulary in code generation and outperforms by one standard deviation in Java code summarization, and in other tasks the performance of 10K and 50K models is similar.  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C ADDITIONAL ANALYSIS</head><p>Additional experiments with "fair" subtoken sequence cropping. In our main experiments, we clip all subtoken sequences with the same maximum length threshold, as this scenario is most close to how it is done in practice. It should be noted that for the vast majority of examples, subtoken sequences fit to the maximum length limit and are not affected by this clipping (see statistics in the main text, Section 2). However, for the remaining long examples, subtoken sequences produced by subtokenizers of higher granularity may be detokenized into longer character sequences, than that of the smaller granularity subtokenizer's. For example, if one uses the maximum length of 4 (only used for illustration), then the code snippet x = sum ( numbers ) may be tokenized by the Level 4 subtokenizer into ['x =', 'sum (', 'numbers', ')'] (fits into the limit) and by 2K subtokenizer into ['x', '=', 'sum', '(', 'numbers', ')'], which will be clipped into ['x', '=', 'sum', '('] with Published as a conference paper at ICLR 2023  </p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Unified pre-training for program understanding and generation</title>
		<author>
			<persName><forename type="first">Wasi</forename><surname>Ahmad</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Saikat</forename><surname>Chakraborty</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Baishakhi</forename><surname>Ray</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kai-Wei</forename><surname>Chang</surname></persName>
		</author>
		<ptr target="https://www.aclweb.org/anthology/2021.naacl-main.211" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2021 Conference of the North American Chapter of the Association for Computational Linguistics: Human Language Technologies</title>
		<meeting>the 2021 Conference of the North American Chapter of the Association for Computational Linguistics: Human Language Technologies</meeting>
		<imprint>
			<publisher>Association for Computational Linguistics</publisher>
			<date type="published" when="2021-06">June 2021</date>
			<biblScope unit="page" from="2655" to="2668" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">Avatar: A parallel corpus for java-python program translation</title>
		<author>
			<persName><forename type="first">Ahmad</forename><surname>Wasi Uddin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Md</forename><surname>Golam Rahman Tushar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Saikat</forename><surname>Chakraborty</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kai-Wei</forename><surname>Chang</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2021">2021</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Efficient inference for multilingual neural machine translation</title>
		<author>
			<persName><forename type="first">Alexandre</forename><surname>Berard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dain</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Stephane</forename><surname>Clinchant</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kweonwoo</forename><surname>Jung</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Vassilina</forename><surname>Nikoulina</surname></persName>
		</author>
		<idno type="DOI">10.18653/v1/2021.emnlp-main.674</idno>
		<ptr target="https://aclanthology.org/2021.emnlp-main.674" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2021 Conference on Empirical Methods in Natural Language Processing</title>
		<meeting>the 2021 Conference on Empirical Methods in Natural Language Processing<address><addrLine>Dominican Republic</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2021-11">November 2021</date>
			<biblScope unit="page" from="8563" to="8583" />
		</imprint>
		<respStmt>
			<orgName>Online and Punta Cana</orgName>
		</respStmt>
	</monogr>
	<note>Association for Computational Linguistics</note>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Byte pair encoding is suboptimal for language model pretraining</title>
		<author>
			<persName><forename type="first">Kaj</forename><surname>Bostrom</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Greg</forename><surname>Durrett</surname></persName>
		</author>
		<idno type="DOI">10.18653/v1/2020.findings-emnlp.414</idno>
		<ptr target="https://aclanthology.org/2020.findings-emnlp" />
	</analytic>
	<monogr>
		<title level="m">Findings of the Association for Computational Linguistics: EMNLP 2020</title>
		<imprint>
			<publisher>Association for Computational Linguistics</publisher>
			<date type="published" when="2020-11">November 2020</date>
			<biblScope unit="page" from="4617" to="4624" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">Mark</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jerry</forename><surname>Tworek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Heewoo</forename><surname>Jun</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Qiming</forename><surname>Yuan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Henrique</forename><surname>Ponde De Oliveira Pinto</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jared</forename><surname>Kaplan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Harri</forename><surname>Edwards</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yuri</forename><surname>Burda</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Nicholas</forename><surname>Joseph</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Greg</forename><surname>Brockman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alex</forename><surname>Ray</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Raul</forename><surname>Puri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gretchen</forename><surname>Krueger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michael</forename><surname>Petrov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Heidy</forename><surname>Khlaaf</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Girish</forename><surname>Sastry</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Pamela</forename><surname>Mishkin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Brooke</forename><surname>Chan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Scott</forename><surname>Gray</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Nick</forename><surname>Ryder</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mikhail</forename><surname>Pavlov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alethea</forename><surname>Power</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Lukasz</forename><surname>Kaiser</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mohammad</forename><surname>Bavarian</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Clemens</forename><surname>Winter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Philippe</forename><surname>Tillet</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Felipe</forename><forename type="middle">Petroski</forename><surname>Such</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dave</forename><surname>Cummings</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Matthias</forename><surname>Plappert</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Fotios</forename><surname>Chantzis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Elizabeth</forename><surname>Barnes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ariel</forename><surname>Herbert-Voss</surname></persName>
		</author>
		<author>
			<persName><forename type="first">William</forename><surname>Hebgen Guss</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alex</forename><surname>Nichol</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alex</forename><surname>Paino</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Nikolas</forename><surname>Tezak</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jie</forename><surname>Tang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Igor</forename><surname>Babuschkin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Suchir</forename><surname>Balaji</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Shantanu</forename><surname>Jain</surname></persName>
		</author>
		<author>
			<persName><forename type="first">William</forename><surname>Saunders</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Christopher</forename><surname>Hesse</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Andrew</forename><forename type="middle">N</forename><surname>Carr</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jan</forename><surname>Leike</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Josh</forename><surname>Achiam</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Vedant</forename><surname>Misra</surname></persName>
		</author>
		<editor>Katie Mayer, Peter Welinder, Bob Mc-Grew, Dario Amodei, Sam McCandlish, Ilya Sutskever</editor>
		<imprint>
			<date type="published" when="2021">2021</date>
			<pubPlace>Evan Morikawa, Alec Radford, Matthew Knight, Miles Brundage, Mira Murati</pubPlace>
		</imprint>
	</monogr>
	<note>and Wojciech Zaremba. Evaluating large language models trained on code</note>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">A simple approach for handling out-of-vocabulary identifiers in deep learning for source code</title>
		<author>
			<persName><forename type="first">Nadezhda</forename><surname>Chirkova</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sergey</forename><surname>Troshin</surname></persName>
		</author>
		<idno type="DOI">10.18653/v1/2021.naacl-main.26</idno>
		<ptr target="https://aclanthology.org/2021.naacl-main.26" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2021 Conference of the North American Chapter of the Association for Computational Linguistics: Human Language Technologies</title>
		<meeting>the 2021 Conference of the North American Chapter of the Association for Computational Linguistics: Human Language Technologies</meeting>
		<imprint>
			<publisher>Association for Computational Linguistics</publisher>
			<date type="published" when="2021-06">June 2021</date>
			<biblScope unit="page" from="278" to="288" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Improving multilingual models with language-clustered vocabularies</title>
		<author>
			<persName><forename type="first">Chung</forename><surname>Hyung Won</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dan</forename><surname>Garrette</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kiat</forename><surname>Chuan Tan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jason</forename><surname>Riesa</surname></persName>
		</author>
		<idno type="DOI">10.18653/v1/2020.emnlp-main.367</idno>
		<ptr target="https://aclanthology.org/2020.emnlp-main.367" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2020 Conference on Empirical Methods in Natural Language Processing (EMNLP)</title>
		<meeting>the 2020 Conference on Empirical Methods in Natural Language Processing (EMNLP)</meeting>
		<imprint>
			<publisher>Association for Computational Linguistics</publisher>
			<date type="published" when="2020-11">November 2020</date>
			<biblScope unit="page" from="4536" to="4546" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title level="m" type="main">Canine: Pre-training an efficient tokenization-free encoder for language representation</title>
		<author>
			<persName><forename type="first">Jonathan</forename><forename type="middle">H</forename><surname>Clark</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dan</forename><surname>Garrette</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Iulia</forename><surname>Turc</surname></persName>
		</author>
		<author>
			<persName><forename type="first">John</forename><surname>Wieting</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2021">2021</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">A call for prudent choice of subword merge operations in neural machine translation</title>
		<author>
			<persName><forename type="first">Shuoyang</forename><surname>Ding</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Adithya</forename><surname>Renduchintala</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kevin</forename><surname>Duh</surname></persName>
		</author>
		<ptr target="https://aclanthology.org/W19-6620" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of Machine Translation Summit XVII: Research Track</title>
		<meeting>Machine Translation Summit XVII: Research Track<address><addrLine>Dublin, Ireland</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2019-08">August 2019</date>
			<biblScope unit="page" from="204" to="213" />
		</imprint>
	</monogr>
	<note>European Association for Machine Translation</note>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">CodeBERT: A pre-trained model for programming and natural languages</title>
		<author>
			<persName><forename type="first">Zhangyin</forename><surname>Feng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Daya</forename><surname>Guo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Duyu</forename><surname>Tang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Nan</forename><surname>Duan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Xiaocheng</forename><surname>Feng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ming</forename><surname>Gong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Linjun</forename><surname>Shou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Bing</forename><surname>Qin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ting</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Daxin</forename><surname>Jiang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ming</forename><surname>Zhou</surname></persName>
		</author>
		<idno type="DOI">10.18653/v1/2020.findings-emnlp.139</idno>
		<ptr target="https://www.aclweb.org/anthology/2020.findings-emnlp.139" />
	</analytic>
	<monogr>
		<title level="m">Findings of the Association for Computational Linguistics: EMNLP 2020</title>
		<imprint>
			<publisher>Association for Computational Linguistics</publisher>
			<date type="published" when="2020-11">November 2020</date>
			<biblScope unit="page" from="1536" to="1547" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">Incoder: A generative model for code infilling and synthesis</title>
		<author>
			<persName><forename type="first">Daniel</forename><surname>Fried</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Armen</forename><surname>Aghajanyan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jessy</forename><surname>Lin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sida</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Eric</forename><surname>Wallace</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Freda</forename><surname>Shi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ruiqi</forename><surname>Zhong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Wen-Tau</forename><surname>Yih</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Luke</forename><surname>Zettlemoyer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mike</forename><surname>Lewis</surname></persName>
		</author>
		<ptr target="https://arxiv.org/abs/2204.05999" />
		<imprint>
			<date type="published" when="2022">2022</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Graphcode{bert}: Pre-training code representations with data flow</title>
		<author>
			<persName><forename type="first">Shuo</forename><surname>Daya Guo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Shuai</forename><surname>Ren</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Zhangyin</forename><surname>Lu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Duyu</forename><surname>Feng</surname></persName>
		</author>
		<author>
			<persName><surname>Tang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Liu</forename><surname>Shujie</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Long</forename><surname>Zhou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Nan</forename><surname>Duan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alexey</forename><surname>Svyatkovskiy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Shengyu</forename><surname>Fu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michele</forename><surname>Tufano</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Colin</forename><surname>Shao Kun Deng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dawn</forename><surname>Clement</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Neel</forename><surname>Drain</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jian</forename><surname>Sundaresan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Daxin</forename><surname>Yin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ming</forename><surname>Jiang</surname></persName>
		</author>
		<author>
			<persName><surname>Zhou</surname></persName>
		</author>
		<ptr target="https://openreview.net/forum?id=jLoC4ez43PZ" />
	</analytic>
	<monogr>
		<title level="m">International Conference on Learning Representations</title>
		<imprint>
			<date type="published" when="2021">2021</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title level="m" type="main">Character-based nmt with transformer</title>
		<author>
			<persName><forename type="first">Rohit</forename><surname>Gupta</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Laurent</forename><surname>Besacier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Marc</forename><surname>Dymetman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Matthias</forename><surname>Gallé</surname></persName>
		</author>
		<idno>ArXiv, abs/1911.04997</idno>
		<imprint>
			<date type="published" when="2019">2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title level="m" type="main">Codesearchnet challenge: Evaluating the state of semantic code search</title>
		<author>
			<persName><forename type="first">Hamel</forename><surname>Husain</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ho-Hsiang</forename><surname>Wu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tiferet</forename><surname>Gazit</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Miltiadis</forename><surname>Allamanis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Marc</forename><surname>Brockschmidt</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2020">2020</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Mapping language to code in programmatic context</title>
		<author>
			<persName><forename type="first">Srinivasan</forename><surname>Iyer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ioannis</forename><surname>Konstas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alvin</forename><surname>Cheung</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Luke</forename><surname>Zettlemoyer</surname></persName>
		</author>
		<idno type="DOI">10.18653/v1/D18-1192</idno>
		<ptr target="https://aclanthology.org/D18-1192" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2018 Conference on Empirical Methods in Natural Language Processing</title>
		<meeting>the 2018 Conference on Empirical Methods in Natural Language Processing<address><addrLine>Brussels, Belgium</addrLine></address></meeting>
		<imprint>
			<publisher>Association for Computational Linguistics</publisher>
			<date type="published" when="2018-11">October-November 2018</date>
			<biblScope unit="page" from="1643" to="1652" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Learning programmatic idioms for scalable semantic parsing</title>
		<author>
			<persName><forename type="first">Srinivasan</forename><surname>Iyer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alvin</forename><surname>Cheung</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Luke</forename><surname>Zettlemoyer</surname></persName>
		</author>
		<idno type="DOI">10.18653/v1/D19-1545</idno>
		<ptr target="https://aclanthology.org/D19-1545" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2019 Conference on Empirical Methods in Natural Language Processing and the 9th International Joint Conference on Natural Language Processing (EMNLP-IJCNLP)</title>
		<meeting>the 2019 Conference on Empirical Methods in Natural Language Processing and the 9th International Joint Conference on Natural Language Processing (EMNLP-IJCNLP)<address><addrLine>Hong Kong, China</addrLine></address></meeting>
		<imprint>
			<publisher>Association for Computational Linguistics</publisher>
			<date type="published" when="2019-11">November 2019</date>
			<biblScope unit="page" from="5426" to="5435" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Learning and evaluating contextual embedding of source code</title>
		<author>
			<persName><forename type="first">Aditya</forename><surname>Kanade</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Petros</forename><surname>Maniatis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gogul</forename><surname>Balakrishnan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kensen</forename><surname>Shi</surname></persName>
		</author>
		<idno>PMLR</idno>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 37th International Conference on Machine Learning, ICML 2020</title>
		<meeting>the 37th International Conference on Machine Learning, ICML 2020</meeting>
		<imprint>
			<date type="published" when="2020-07-18">12-18 July 2020. 2020</date>
		</imprint>
	</monogr>
	<note>Proceedings of Machine Learning Research</note>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Big code != big vocabulary: Open-vocabulary models for source code</title>
		<author>
			<persName><forename type="first">Rafael-Michael</forename><surname>Karampatsis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hlib</forename><surname>Babii</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Romain</forename><surname>Robbes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Charles</forename><surname>Sutton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Andrea</forename><surname>Janes</surname></persName>
		</author>
		<idno type="DOI">10.1145/3377811.3380342</idno>
		<ptr target="https://doi.org/10.1145/3377811.3380342" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ACM/IEEE 42nd International Conference on Software Engineering, ICSE &apos;20</title>
		<meeting>the ACM/IEEE 42nd International Conference on Software Engineering, ICSE &apos;20<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>Association for Computing Machinery</publisher>
			<date type="published" when="2020">2020</date>
			<biblScope unit="page" from="1073" to="1085" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Subword regularization: Improving neural network translation models with multiple subword candidates</title>
		<author>
			<persName><forename type="first">Taku</forename><surname>Kudo</surname></persName>
		</author>
		<idno type="DOI">10.18653/v1/P18-1007</idno>
		<ptr target="https://aclanthology.org/P18-1007" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 56th Annual Meeting of the Association for Computational Linguistics</title>
		<meeting>the 56th Annual Meeting of the Association for Computational Linguistics<address><addrLine>Melbourne, Australia</addrLine></address></meeting>
		<imprint>
			<publisher>Association for Computational Linguistics</publisher>
			<date type="published" when="2018-07">July 2018</date>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="66" to="75" />
		</imprint>
	</monogr>
	<note>Long Papers)</note>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">SentencePiece: A simple and language independent subword tokenizer and detokenizer for neural text processing</title>
		<author>
			<persName><forename type="first">Taku</forename><surname>Kudo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">John</forename><surname>Richardson</surname></persName>
		</author>
		<idno type="DOI">10.18653/v1/D18-2012</idno>
		<ptr target="https://aclanthology.org/D18-2012" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2018 Conference on Empirical Methods in Natural Language Processing: System Demonstrations</title>
		<meeting>the 2018 Conference on Empirical Methods in Natural Language Processing: System Demonstrations<address><addrLine>Brussels, Belgium</addrLine></address></meeting>
		<imprint>
			<publisher>Association for Computational Linguistics</publisher>
			<date type="published" when="2018-11">November 2018</date>
			<biblScope unit="page" from="66" to="71" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">BART: Denoising sequence-to-sequence pretraining for natural language generation, translation, and comprehension</title>
		<author>
			<persName><forename type="first">Mike</forename><surname>Lewis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yinhan</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Naman</forename><surname>Goyal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Marjan</forename><surname>Ghazvininejad</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Abdelrahman</forename><surname>Mohamed</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Omer</forename><surname>Levy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Veselin</forename><surname>Stoyanov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Luke</forename><surname>Zettlemoyer</surname></persName>
		</author>
		<idno type="DOI">10.18653/v1/2020.acl-main.703</idno>
		<ptr target="https://aclanthology.org/2020.acl-main.703" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 58th Annual Meeting of the Association for Computational Linguistics</title>
		<meeting>the 58th Annual Meeting of the Association for Computational Linguistics</meeting>
		<imprint>
			<publisher>Association for Computational Linguistics</publisher>
			<date type="published" when="2020-07">July 2020</date>
			<biblScope unit="page" from="7871" to="7880" />
		</imprint>
	</monogr>
	<note>Online</note>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<author>
			<persName><forename type="first">Yujia</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><surname>Choi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Junyoung</forename><surname>Chung</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Nate</forename><surname>Kushman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Julian</forename><surname>Schrittwieser</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Rémi</forename><surname>Leblond</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tom</forename><surname>Eccles</surname></persName>
		</author>
		<author>
			<persName><forename type="first">James</forename><surname>Keeling</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Felix</forename><surname>Gimeno</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Agustin</forename><forename type="middle">Dal</forename><surname>Lago</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Thomas</forename><surname>Hubert</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Peter</forename><surname>Choy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Cyprien</forename><surname>De Masson D'autume</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Igor</forename><surname>Babuschkin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Xinyun</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Po-Sen</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Johannes</forename><surname>Welbl</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sven</forename><surname>Gowal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alexey</forename><surname>Cherepanov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">James</forename><surname>Molloy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Daniel</forename><forename type="middle">J</forename><surname>Mankowitz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Esme</forename><surname>Sutherland Robson</surname></persName>
		</author>
		<ptr target="https://arxiv.org/abs/2203.07814" />
	</analytic>
	<monogr>
		<title level="m">Nando de Freitas, Koray Kavukcuoglu, and Oriol Vinyals. Competition-level code generation with alphacode</title>
		<imprint>
			<date type="published" when="2022">2022</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<monogr>
		<title level="m" type="main">Roberta: A robustly optimized bert pretraining approach</title>
		<author>
			<persName><forename type="first">Yinhan</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Myle</forename><surname>Ott</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Naman</forename><surname>Goyal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jingfei</forename><surname>Du</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mandar</forename><surname>Joshi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Danqi</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Omer</forename><surname>Levy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mike</forename><surname>Lewis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Luke</forename><surname>Zettlemoyer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Veselin</forename><surname>Stoyanov</surname></persName>
		</author>
		<idno>ArXiv, abs/1907.11692</idno>
		<imprint>
			<date type="published" when="2019">2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<monogr>
		<title level="m" type="main">Codexglue: A machine learning benchmark dataset for code understanding and generation</title>
		<author>
			<persName><forename type="first">Shuai</forename><surname>Lu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Daya</forename><surname>Guo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Shuo</forename><surname>Ren</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Junjie</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alexey</forename><surname>Svyatkovskiy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ambrosio</forename><surname>Blanco</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Colin</forename><forename type="middle">B</forename><surname>Clement</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dawn</forename><surname>Drain</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Daxin</forename><surname>Jiang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Duyu</forename><surname>Tang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ge</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Lidong</forename><surname>Zhou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Linjun</forename><surname>Shou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Long</forename><surname>Zhou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michele</forename><surname>Tufano</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ming</forename><surname>Gong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ming</forename><surname>Zhou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Nan</forename><surname>Duan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Neel</forename><surname>Sundaresan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Shengyu</forename><surname>Shao Kun Deng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Shujie</forename><surname>Fu</surname></persName>
		</author>
		<author>
			<persName><surname>Liu</surname></persName>
		</author>
		<idno>CoRR, abs/2102.04664</idno>
		<imprint>
			<date type="published" when="2021">2021</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<monogr>
		<title level="m" type="main">Between words and characters: A brief history of open-vocabulary modeling and tokenization in nlp</title>
		<author>
			<persName><forename type="first">Sabrina</forename><forename type="middle">J</forename><surname>Mielke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Zaid</forename><surname>Alyafeai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Elizabeth</forename><surname>Salesky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Colin</forename><surname>Raffel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Manan</forename><surname>Dey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Matthias</forename><surname>Gallé</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Arun</forename><surname>Raja</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Chenglei</forename><surname>Si</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Wilson</forename><forename type="middle">Y</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Benoît</forename><surname>Sagot</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Samson</forename><surname>Tan</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2021">2021</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">BPE-dropout: Simple and effective subword regularization</title>
		<author>
			<persName><forename type="first">Ivan</forename><surname>Provilkov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dmitrii</forename><surname>Emelianenko</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Elena</forename><surname>Voita</surname></persName>
		</author>
		<idno type="DOI">10.18653/v1/2020.acl-main.170</idno>
		<ptr target="https://aclanthology.org/2020.acl-main.170" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 58th Annual Meeting of the Association for Computational Linguistics</title>
		<meeting>the 58th Annual Meeting of the Association for Computational Linguistics</meeting>
		<imprint>
			<date type="published" when="2020-07">July 2020</date>
			<biblScope unit="page" from="1882" to="1892" />
		</imprint>
	</monogr>
	<note>Association for Computational Linguistics</note>
</biblStruct>

<biblStruct xml:id="b26">
	<monogr>
		<title level="m" type="main">Improving language understanding by generative pretraining</title>
		<author>
			<persName><forename type="first">Alec</forename><surname>Radford</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Karthik</forename><surname>Narasimhan</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2018">2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<monogr>
		<title level="m" type="main">Language models are unsupervised multitask learners</title>
		<author>
			<persName><forename type="first">Alec</forename><surname>Radford</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jeffrey</forename><surname>Wu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Rewon</forename><surname>Child</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><surname>Luan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dario</forename><surname>Amodei</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ilya</forename><surname>Sutskever</surname></persName>
		</author>
		<ptr target="https://d4mucfpksywv.cloudfront.net/better-language-models/language-models.pdf" />
		<imprint>
			<date type="published" when="2018">2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Exploring the limits of transfer learning with a unified text-totext transformer</title>
		<author>
			<persName><forename type="first">Colin</forename><surname>Raffel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Noam</forename><surname>Shazeer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Adam</forename><surname>Roberts</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Katherine</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sharan</forename><surname>Narang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michael</forename><surname>Matena</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yanqi</forename><surname>Zhou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Wei</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Peter</forename><forename type="middle">J</forename><surname>Liu</surname></persName>
		</author>
		<ptr target="http://jmlr.org/papers/v21/20-074.html" />
	</analytic>
	<monogr>
		<title level="j">Journal of Machine Learning Research</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="issue">140</biblScope>
			<biblScope unit="page" from="1" to="67" />
			<date type="published" when="2020">2020</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<monogr>
		<title level="m" type="main">Codebleu: a method for automatic evaluation of code synthesis</title>
		<author>
			<persName><forename type="first">Daya</forename><surname>Shuo Ren</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Shuai</forename><surname>Guo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Long</forename><surname>Lu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Shujie</forename><surname>Zhou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Duyu</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Tang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ambrosio</forename><surname>Zhou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Shuai</forename><surname>Blanco</surname></persName>
		</author>
		<author>
			<persName><surname>Ma</surname></persName>
		</author>
		<idno>ArXiv, abs/2009.10297</idno>
		<imprint>
			<date type="published" when="2020">2020</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Unsupervised translation of programming languages</title>
		<author>
			<persName><forename type="first">Marie-Anne</forename><surname>Baptiste Roziere</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Lowik</forename><surname>Lachaux</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Guillaume</forename><surname>Chanussot</surname></persName>
		</author>
		<author>
			<persName><surname>Lample</surname></persName>
		</author>
		<ptr target="https://proceedings.neurips.cc/paper/2020/file/ed23" />
	</analytic>
	<monogr>
		<title level="m">Advances in Neural Information Processing Systems</title>
		<editor>
			<persName><forename type="first">H</forename><surname>Larochelle</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><surname>Ranzato</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">R</forename><surname>Hadsell</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><forename type="middle">F</forename><surname>Balcan</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">H</forename><surname>Lin</surname></persName>
		</editor>
		<imprint>
			<publisher>Curran Associates, Inc</publisher>
			<date type="published" when="2020">2020</date>
			<biblScope unit="volume">33</biblScope>
			<biblScope unit="page" from="20601" to="20611" />
		</imprint>
	</monogr>
	<note>cd35f8c7f8de44f85c08d-Paper.pdf</note>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Dobf: A deobfuscation pre-training objective for programming languages</title>
		<author>
			<persName><forename type="first">Marie-Anne</forename><surname>Baptiste Roziere</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Marc</forename><surname>Lachaux</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Guillaume</forename><surname>Szafraniec</surname></persName>
		</author>
		<author>
			<persName><surname>Lample</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Neural Information Processing Systems</title>
		<imprint>
			<publisher>Online</publisher>
			<date type="published" when="2021">NeurIPS 2021. 2021</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">How good is your tokenizer? on the monolingual performance of multilingual language models</title>
		<author>
			<persName><forename type="first">Phillip</forename><surname>Rust</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jonas</forename><surname>Pfeiffer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ivan</forename><surname>Vulić</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sebastian</forename><surname>Ruder</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Iryna</forename><surname>Gurevych</surname></persName>
		</author>
		<idno>doi: 10.18653</idno>
		<ptr target="1/2021.acl-long" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 59th Annual Meeting of the Association for Computational Linguistics and the 11th International Joint Conference on Natural Language Processing</title>
		<meeting>the 59th Annual Meeting of the Association for Computational Linguistics and the 11th International Joint Conference on Natural Language Processing<address><addrLine>Online</addrLine></address></meeting>
		<imprint>
			<publisher>Association for Computational Linguistics</publisher>
			<date type="published" when="2021-08">August 2021</date>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="3118" to="3135" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<monogr>
		<ptr target="https://aclanthology.org/2021.acl-long.243" />
		<title level="m">URL</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Neural machine translation of rare words with subword units</title>
		<author>
			<persName><forename type="first">Rico</forename><surname>Sennrich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Barry</forename><surname>Haddow</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alexandra</forename><surname>Birch</surname></persName>
		</author>
		<idno type="DOI">10.18653/v1/P16-1162</idno>
		<ptr target="https://aclanthology.org/P16-1162" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 54th Annual Meeting of the Association for Computational Linguistics</title>
		<meeting>the 54th Annual Meeting of the Association for Computational Linguistics<address><addrLine>Berlin, Germany</addrLine></address></meeting>
		<imprint>
			<publisher>Association for Computational Linguistics</publisher>
			<date type="published" when="2016-08">August 2016</date>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="1715" to="1725" />
		</imprint>
	</monogr>
	<note>Long Papers)</note>
</biblStruct>

<biblStruct xml:id="b35">
	<monogr>
		<title level="m" type="main">Program Synthesis and Semantic Parsing with Learned Code Idioms</title>
		<author>
			<persName><forename type="first">Richard</forename><surname>Shin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Miltiadis</forename><surname>Allamanis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Marc</forename><surname>Brockschmidt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Oleksandr</forename><surname>Polozov</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2019">2019</date>
			<publisher>Curran Associates Inc</publisher>
			<pubPlace>Red Hook, NY, USA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Evaluating clone detection tools with bigclonebench</title>
		<author>
			<persName><forename type="first">Jeffrey</forename><surname>Svajlenko</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Chanchal</forename><forename type="middle">K</forename><surname>Roy</surname></persName>
		</author>
		<idno type="DOI">10.1109/ICSM.2015.7332459</idno>
	</analytic>
	<monogr>
		<title level="m">2015 IEEE International Conference on Software Maintenance and Evolution (ICSME)</title>
		<imprint>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="131" to="140" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<monogr>
		<title level="m" type="main">Charformer: Fast character transformers via gradient-based subword tokenization</title>
		<author>
			<persName><forename type="first">Yi</forename><surname>Tay</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Q</forename><surname>Vinh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sebastian</forename><surname>Tran</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jai</forename><surname>Ruder</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hyung</forename><forename type="middle">Won</forename><surname>Gupta</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dara</forename><surname>Chung</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Zhen</forename><surname>Bahri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Simon</forename><surname>Qin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Cong</forename><surname>Baumgartner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Donald</forename><surname>Yu</surname></persName>
		</author>
		<author>
			<persName><surname>Metzler</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2021">2021</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Tensor2Tensor for neural machine translation</title>
		<author>
			<persName><forename type="first">Ashish</forename><surname>Vaswani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Samy</forename><surname>Bengio</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Eugene</forename><surname>Brevdo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Francois</forename><surname>Chollet</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Aidan</forename><surname>Gomez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Stephan</forename><surname>Gouws</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Llion</forename><surname>Jones</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Łukasz</forename><surname>Kaiser</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Nal</forename><surname>Kalchbrenner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Niki</forename><surname>Parmar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ryan</forename><surname>Sepassi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Noam</forename><surname>Shazeer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jakob</forename><surname>Uszkoreit</surname></persName>
		</author>
		<ptr target="https://aclanthology.org/W18-1819" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 13th Conference of the Association for Machine Translation in the Americas</title>
		<meeting>the 13th Conference of the Association for Machine Translation in the Americas<address><addrLine>Boston, MA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2018-03">March 2018</date>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="193" to="199" />
		</imprint>
	</monogr>
	<note>Research Track Association for Machine Translation in the Americas</note>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">a. Association for Computational Linguistics</title>
		<author>
			<persName><forename type="first">Xinyi</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sebastian</forename><surname>Ruder</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Graham</forename><surname>Neubig</surname></persName>
		</author>
		<idno type="DOI">10.18653/v1/2021.naacl-main.40</idno>
		<ptr target="https://aclanthology.org/2021.naacl-main.40" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2021 Conference of the North American Chapter of the Association for Computational Linguistics: Human Language Technologies</title>
		<meeting>the 2021 Conference of the North American Chapter of the Association for Computational Linguistics: Human Language Technologies</meeting>
		<imprint>
			<date type="published" when="2021-06">June 2021</date>
			<biblScope unit="page" from="473" to="482" />
		</imprint>
	</monogr>
	<note>Multi-view subword regularization</note>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">CodeT5: Identifier-aware unified pre-trained encoder-decoder models for code understanding and generation</title>
		<author>
			<persName><forename type="first">Yue</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Weishi</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Shafiq</forename><surname>Joty</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Steven</forename><forename type="middle">C H</forename><surname>Hoi</surname></persName>
		</author>
		<ptr target="https://aclanthology.org/2021.emnlp-main.685" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2021 Conference on Empirical Methods in Natural Language Processing</title>
		<meeting>the 2021 Conference on Empirical Methods in Natural Language Processing<address><addrLine>Dominican Republic</addrLine></address></meeting>
		<imprint>
			<publisher>Association for Computational Linguistics</publisher>
			<date type="published" when="2021-11">November 2021</date>
			<biblScope unit="page" from="8696" to="8708" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<monogr>
		<title level="m" type="main">Google&apos;s neural machine translation system: Bridging the gap between human and machine translation</title>
		<author>
			<persName><forename type="first">Yonghui</forename><surname>Wu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mike</forename><surname>Schuster</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Zhifeng</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Quoc</forename><forename type="middle">V</forename><surname>Le</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mohammad</forename><surname>Norouzi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Wolfgang</forename><surname>Macherey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Maxim</forename><surname>Krikun</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yuan</forename><surname>Cao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Qin</forename><surname>Gao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Klaus</forename><surname>Macherey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jeff</forename><surname>Klingner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Apurva</forename><surname>Shah</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Melvin</forename><surname>Johnson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Xiaobing</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Lukasz</forename><surname>Kaiser</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Stephan</forename><surname>Gouws</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yoshikiyo</forename><surname>Kato</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Taku</forename><surname>Kudo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hideto</forename><surname>Kazawa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Keith</forename><surname>Stevens</surname></persName>
		</author>
		<author>
			<persName><forename type="first">George</forename><surname>Kurian</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Nishant</forename><surname>Patil</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Wei</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Cliff</forename><surname>Young</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jason</forename><surname>Smith</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jason</forename><surname>Riesa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alex</forename><surname>Rudnick</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Oriol</forename><surname>Vinyals</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Greg</forename><surname>Corrado</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Macduff</forename><surname>Hughes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jeffrey</forename><surname>Dean</surname></persName>
		</author>
		<idno>CoRR, abs/1609.08144</idno>
		<ptr target="http://arxiv.org/abs/1609.08144" />
		<imprint>
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
